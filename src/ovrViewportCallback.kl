/*
 *  Copyright 2010-2014 Fabric Software Inc. All rights reserved.
 */

require SpliceStandalone;
require Singletons;

object ovrViewportCallback : SpliceStandaloneViewportCallback {
  ovrDevice device;
  ovrDescription desc;
  UInt32 fbo[];
  UInt32 fb_width;
  UInt32 fb_height;
  UInt32 fb_tex_width;
  UInt32 fb_tex_height;
  UInt32 fb_tex[];
  UInt32 fb_depth[];
  ovrGLTexture fb_ovr_tex[2];
  ovrGLConfig cfg;
  ovrEyeRenderDesc eye_rdesc[2];
  ovrPose poses[2];
};

function ovrViewportCallback() {
  this.device = null;
  this.fbo.push(0);
  this.fb_tex.push(0);
  this.fb_tex.push(0);
  this.fb_depth.push(0);
}

function ovrViewportCallback(ovrDevice device) {
  this.device = device;
  this.desc = device.getDescription();
  this.fbo.push(0);
  this.fb_tex.push(0);
  this.fb_depth.push(0);
}

function ovrViewportCallback.registerForViewport!() {
  SpliceStandaloneViewport viewport = Singleton_get('Viewport');
  if(viewport) {
    viewport.registerCallback(SpliceStandaloneViewportPhase_Initialize, this);
    viewport.registerCallback(SpliceStandaloneViewportPhase_Resize, this);
    viewport.registerCallback(SpliceStandaloneViewportPhase_BeforePaint, this);
    viewport.registerCallback(SpliceStandaloneViewportPhase_Paint, this);
    viewport.registerCallback(SpliceStandaloneViewportPhase_AfterPaint, this);
  }
}

/*
const SpliceStandaloneViewportPhase SpliceStandaloneViewportPhase_Initialize = 0;
const SpliceStandaloneViewportPhase SpliceStandaloneViewportPhase_Resize = 1;
const SpliceStandaloneViewportPhase SpliceStandaloneViewportPhase_BeforePaint = 2;
const SpliceStandaloneViewportPhase SpliceStandaloneViewportPhase_Paint = 3;
const SpliceStandaloneViewportPhase SpliceStandaloneViewportPhase_AfterPaint = 4;
*/

function UInt32 next_pow2(UInt32 x) {
  UInt32 y = x - 1;
  y |= y >> 1;
  y |= y >> 2;
  y |= y >> 4;
  y |= y >> 8;
  y |= y >> 16;
  return y + 1;
}

function Boolean ovrViewportCallback.perform!(SpliceStandaloneViewportPhase phase, io SpliceStandaloneViewport viewport) {
  switch(phase) {
    case SpliceStandaloneViewportPhase_Initialize: {

      if(this.fbo[0])
        return true;

      // {
      //   glGenRenderbuffers(1, this.fb_depth);        
      //   glDeleteTextures(1, this.fb_tex);        
      //   glDeleteFrameBuffers(1, this.fbo);        
      // }

      ovrSize eyeRes[2];
      eyeRes[0] = this.device.getFovTextureSize(ovrEye_Left);
      eyeRes[1] = this.device.getFovTextureSize(ovrEye_Right);
      this.fb_width = eyeRes[0].w + eyeRes[1].w;
      this.fb_height = eyeRes[0].h > eyeRes[1].h ? eyeRes[0].h : eyeRes[1].h;
      // this.fb_width = viewport.width;
      // this.fb_height = viewport.height;

      /* calculate the next power of two in both dimensions and use that as a texture size */
      // this.fb_tex_width = next_pow2(this.fb_width);
      // this.fb_tex_height = next_pow2(this.fb_height);
      this.fb_tex_width = this.fb_width;
      this.fb_tex_height = this.fb_height;

      glGenFramebuffers(1, this.fbo);
      glGenTextures(1, this.fb_tex);
      glGenRenderbuffers(1, this.fb_depth);
      glBindTexture(GL_TEXTURE_2D, this.fb_tex[0]);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);        

      glBindFramebuffer(GL_FRAMEBUFFER, this.fbo[0]);

      Data nullData;

      /* create and attach the texture that will be used as a color buffer */
      glBindTexture(GL_TEXTURE_2D, this.fb_tex[0]);
      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, this.fb_tex_width, this.fb_tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullData);
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this.fb_tex[0], 0);

      /* create and attach the renderbuffer that will serve as our z-buffer */
      glBindRenderbuffer(GL_RENDERBUFFER, this.fb_depth[0]);
      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, this.fb_tex_width, this.fb_tex_height);
      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, this.fb_depth[0]);
      if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        setError("incomplete framebuffer!");
      }
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      report("Created render target: "+this.fb_width+"x"+this.fb_height+" (texture size: "+this.fb_tex_width+"x"+this.fb_tex_height+")"+", (window size: "+this.desc.Resolution.w+"x"+this.desc.Resolution.h+")");

      /* fill in the ovrGLTexture structures that describe our render target texture */
      for(ovrEyeType i=0; i<ovrEye_Count; i++) {
        this.fb_ovr_tex[i].API = ovrRenderAPI_OpenGL;
        this.fb_ovr_tex[i].TextureSize.w = this.fb_tex_width;
        this.fb_ovr_tex[i].TextureSize.h = this.fb_tex_height;

        /* this next field is the only one that differs between the two eyes */
        this.fb_ovr_tex[i].RenderViewport.Pos.x = i == 0 ? 0 : this.fb_width / 2.0;
        this.fb_ovr_tex[i].RenderViewport.Pos.y = this.fb_tex_height - this.fb_height;
        this.fb_ovr_tex[i].RenderViewport.Size.w = this.fb_width / 2.0;
        this.fb_ovr_tex[i].RenderViewport.Size.h = this.fb_height;
        this.fb_ovr_tex[i].TexId = this.fb_tex[0]; /* both eyes will use the same texture id */
      } 

      this.cfg.API = ovrRenderAPI_OpenGL;
      this.cfg.RTSize = this.desc.Resolution;
      this.cfg.Multisample = 1;      
      this.cfg.Window = viewport.windowId;

      /// on windows this will perform direct rendering
      report(this.cfg);
      this.device.attachToWindow(this.cfg.Window);

      /* enable low-persistence display and dynamic prediction for lattency compensation */
      this.device.setEnabledCaps(ovrHmdCap_LowPersistence | ovrHmdCap_DynamicPrediction);
      
      /* configure SDK-rendering and enable chromatic abberation correction, vignetting, and
      * timewrap, which shifts the image before drawing to counter any lattency between the call
      * to ovrDevice.GetEyePose and ovrDevice.EndFrame.
      */
      Integer dcaps = ovrDistortionCap_Chromatic | ovrDistortionCap_Vignette | ovrDistortionCap_TimeWarp | ovrDistortionCap_Overdrive;
      if(!this.device.configureRendering(this.cfg, dcaps, this.desc.DefaultEyeFov, this.eye_rdesc)) {
        setError("Failed to configure distortion renderer.");
      }
      
      /* disable the retarded "health and safety warning" */
      this.device.enableHSWDisplaySDKRender(false);
      
      glEnable(GL_DEPTH_TEST);
      glClearColor(0.1, 0.1, 0.3, 1);

      if(!viewport.gridInstance)
      {
        // setup the grid
        InlineDrawing drawing = OGLInlineDrawing_GetInstance();

        InlineDebugShape grid = drawing.registerShape(InlineDebugShape('StandaloneGrid'));

        Scalar scale = 2.0;
        for(Integer x=-10;x<11;x++)
          grid.drawLine(Vec3(x, 0, -10) * scale, Vec3(x, 0, 10) * scale);
        for(Integer z=-10;z<11;z++)
          grid.drawLine(Vec3(-10, 0, z) * scale, Vec3(10, 0, z) * scale);

        InlineShader shader = drawing.registerShader(OGLFlatShader());
        InlineMaterial mat = shader.getOrCreateMaterial('grey');
        mat.setUniform('u_color', Color(0.9, 0.9, 0.9));
        viewport.gridInstance = InlineInstance('StandaloneGrid', drawing.getRoot(), grid, mat);
      }

      return true; // skip default behaviour
    }
    case SpliceStandaloneViewportPhase_Resize: {

      return false; // skip default behaviour

    }
    case SpliceStandaloneViewportPhase_BeforePaint: {

      /* the drawing starts with a call to ovrDevice.BeginFrame */
      if(this.device.isStereoEnabled()) {
        this.device.beginFrame(0);

        /* start drawing onto our texture render target */
        glBindFramebuffer(GL_FRAMEBUFFER, this.fbo[0]);
      }

      glViewport(0, 0, this.fb_width, this.fb_height);
      glClearColor(0.0, 0.0, 0.5, 1);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

      return true;

    }
    case SpliceStandaloneViewportPhase_Paint: {

      InlineDrawing drawing = OGLInlineDrawing_GetInstance();
      this.poses = this.device.getEyePoses();

      glMatrixMode(GL_MODELVIEW);

      /* for each eye ... */
      for(ovrEyeType eye=0; eye<ovrEye_Count; eye++) {

        if(this.device.isStereoEnabled())
          glViewport(eye == ovrEye_Left ? 0 : this.fb_width / 2, 0, this.fb_width / 2, this.fb_height);
        
        glLoadIdentity();

        Xfo camXfo;
        camXfo.ori = this.poses[eye].Orientation;
        camXfo.tr = this.poses[eye].Position * 10;
        viewport.drawContext.viewport.camera.mat44 = camXfo.toMat44();
        // todo
        // viewport.drawContext.viewport.camera.fovY = this.camera.fovY;
        // viewport.drawContext.viewport.camera.nearDistance = this.camera.nearValue;
        // viewport.drawContext.viewport.camera.farDistance = this.camera.farValue;

        /* finally draw the scene for this eye */
        drawing.draw(viewport.drawContext);

        if(!this.device.isStereoEnabled())
          break;
      }
      
      return true; // skip default behaviour

    }
    case SpliceStandaloneViewportPhase_AfterPaint: {

      if(this.device.isStereoEnabled()) {
        glBindFramebuffer(GL_FRAMEBUFFER, 0);

        // glViewport(0, 0, this.desc.Resolution.w, this.desc.Resolution.h);
        glViewport(0, 0, viewport.width, viewport.height);
        glClearColor(0.0, 0.0, 0.0, 1);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        this.device.endFrame(this.poses, this.fb_ovr_tex);
      }

      return true; // skip default behaviour

    }
  }
  return false;
}
