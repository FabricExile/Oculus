/*
 *  Copyright 2010-2014 Fabric Software Inc. All rights reserved.
 */

require InlineDrawing:">1.0.0";
require Singletons;

object ovrViewportCallback : ViewportCallback {
  ovrDevice device;
  ovrDescription desc;
  Color bgColor;
  ovrGLTextureBuffer tBuffers[];
  ovrGLDepthBuffer dBuffers[];
  ovrGLMirrorTexture mirror;
  ovrSize eyeRes[2];
  ovrEyeRenderDesc eye_rdesc[2];
  ovrPose poses[2];
  ovrViewScaleDesc viewScaleDesc;
  ovrLayerEyeFov layerEyeFov;
  Float32 poseScale;
  Vec3 walkOffset;
  Quat turnOffset;
  Xfo worldXfo;
  Boolean requiresSetup;
};

/// \dfgPresetOmit
function ovrViewportCallback() {
  this.init(null);
}

function ovrViewportCallback(ovrDevice device) {
  this.init(device);
}

/// \dfgPresetOmit
function ovrViewportCallback.init!(ovrDevice device) {
  this.device = device;
  if(device) {
    this.desc = device.getDescription();
    this.eye_rdesc[ovrEye_Left] = device.getRenderDesc(ovrEye_Left, this.desc.DefaultEyeFov[ovrEye_Left]);
    this.eye_rdesc[ovrEye_Right] = device.getRenderDesc(ovrEye_Right, this.desc.DefaultEyeFov[ovrEye_Right]);
    this.requiresSetup = true;
  }
  else
  {
    this.requiresSetup = false;
  }
  this.bgColor = Color(0.2, 0.2, 0.2, 1.0);
  this.poseScale = 10.0;
}

/// \dfgPresetOmit
function ovrViewportCallback.registerForViewport!(String viewportName) {
  InlineDrawing drawing = Singleton_get('InlineDrawing');
  Viewport viewport = drawing.getViewport(viewportName);
  if(viewport) {
    viewport.registerCallback(ViewportDrawPhase_Setup, this);
    viewport.registerCallback(ViewportDrawPhase_Resize, this);
    viewport.registerCallback(ViewportDrawPhase_PreDraw, this);
    viewport.registerCallback(ViewportDrawPhase_Draw, this);
    viewport.registerCallback(ViewportDrawPhase_PostDraw, this);
    report('ovrViewportCallback::registerForViewport succeeded ('+viewportName+').');
  } else {
    report('ovrViewportCallback::registerForViewport: viewport "'+viewportName+'" not found!');
  }
}

function ovrViewportCallback.registerForViewport!() {
  InlineDrawingBase drawing = Singleton_get('InlineDrawing');
  for(key in drawing.viewports) {
    this.registerForViewport(key);
    break;
  }
}

/// \dfgPresetOmit
function Boolean ovrViewportCallback.invoke!(ViewportDrawPhase phase, io Viewport viewport, io DrawContext context) {
  OGLStandaloneViewport vp = viewport;
  if(!vp) {
    setError('The viewport has to be a OGLStandaloneViewport, since we need access to the windowId.');
    return false;
  }

  switch(phase) {
    case ViewportDrawPhase_Resize:
    case ViewportDrawPhase_Setup: {

      if(!this.requiresSetup)
        return false;

      report('ovrViewportCallback:: ViewportDrawPhase_Setup');

      if(this.tBuffers.size() == 0)
      {
        this.tBuffers.resize(2);
        this.dBuffers.resize(2);

        for(ovrEyeType eye=0; eye<ovrEye_Count; eye++) {

          this.eyeRes[eye] = this.device.getFovTextureSize(eye, this.desc.DefaultEyeFov[eye], 1);
          this.tBuffers[eye] = ovrGLTextureBuffer(this.device, true, true, this.eyeRes[eye], 1, 1);
          this.dBuffers[eye] = ovrGLDepthBuffer(this.tBuffers[eye].getSize(), 0);

        }

        report('ovrViewportCallback:: Framebuffers created.');
      }

      this.viewScaleDesc.HmdSpaceToWorldScaleInMeters = 1.0f;
      this.viewScaleDesc.HmdToEyeViewOffset[ovrEye_Left] = this.eye_rdesc[ovrEye_Left].HmdToEyeViewOffset;
      this.viewScaleDesc.HmdToEyeViewOffset[ovrEye_Right] = this.eye_rdesc[ovrEye_Right].HmdToEyeViewOffset;

      this.layerEyeFov.Header.Type  = ovrLayerType_EyeFov;
      this.layerEyeFov.Header.Flags = ovrLayerFlag_TextureOriginAtBottomLeft;   // Because OpenGL.

      for(ovrEyeType eye=0; eye<ovrEye_Count; eye++) {
        this.layerEyeFov.ColorTexture[eye] = this.tBuffers[eye];
        this.layerEyeFov.Viewport[eye]     = this.eyeRes[eye];
        this.layerEyeFov.Fov[eye]          = this.desc.DefaultEyeFov[eye];
      }

      ovrSize windowSize(vp.dimensions.x, vp.dimensions.y);
      this.mirror = ovrGLMirrorTexture(this.device, windowSize);

      glEnable(GL_DEPTH_TEST);
      glClearColor(this.bgColor.r, this.bgColor.g, this.bgColor.b, this.bgColor.a);

      return false;
    }
    case ViewportDrawPhase_PreDraw: {

      return true;

    }
    case ViewportDrawPhase_Draw: {

      if(this.tBuffers.size() == 0)
        return false;

      InlineDrawing drawing = OGLInlineDrawing_GetInstance();

      Vec3 viewOffset[2];
      viewOffset[ovrEye_Left] = this.eye_rdesc[ovrEye_Left].HmdToEyeViewOffset;
      viewOffset[ovrEye_Right] = this.eye_rdesc[ovrEye_Right].HmdToEyeViewOffset;

      // ovrFrameTiming ftiming = this.device.getFrameTiming(0);
      // ovrTrackingState tstate = this.device.getTrackingState(ftiming.DisplayMidpointSeconds);
      ovrTrackingState tstate = this.device.getTrackingState(0.0);
      this.poses = this.device.calcEyePoses(tstate.HeadPose.ThePose, viewOffset);

      /* for each eye ... */
      for(ovrEyeType eye=0; eye<ovrEye_Count; eye++) {

        glClearColor(this.bgColor.r, this.bgColor.g, this.bgColor.b, this.bgColor.a);

        if(this.device.isStereoEnabled()) {

          // Switch to eye render target
          this.tBuffers[eye].setAndClearRenderSurface(this.dBuffers[eye]);

        }

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();

        glLoadIdentity();

        Xfo camXfo;
        camXfo.ori = this.poses[eye].Orientation;
        camXfo.ori = this.turnOffset * camXfo.ori;

        InlineCamera camera = vp.getCamera();
        if(eye == ovrEye_Left) {
          Vec3 xAxis = camXfo.ori.getXaxis();
          Vec3 yAxis = camXfo.ori.getYaxis();
          Vec3 zAxis = xAxis.cross(Vec3(0.0,1.0,0.0)).unit();
          this.walkOffset += camera.currLinearVelocity.x * xAxis;
          this.walkOffset += camera.currLinearVelocity.y * yAxis;
          this.walkOffset += camera.currLinearVelocity.z * zAxis;

          Quat angularDelta;
          angularDelta.setFromAxisAndAngle(Vec3(0.0, 1.0, 0.0), camera.currAngularVelocity.x);
          this.turnOffset = angularDelta * this.turnOffset;
        }

        camXfo.tr = this.turnOffset.rotateVector(this.poses[eye].Position) * this.poseScale + this.walkOffset;

        if(eye == ovrEye_Left)
          this.worldXfo = camXfo;
        
        camera.xfo = camXfo;
        if(this.device.isStereoEnabled())
          camera.projection = this.device.getProjectionMat44(this.desc.DefaultEyeFov[eye], camera.nearDistance, camera.farDistance, ovrProjection_RightHanded);
        else
          camera.projection.setNull();

        /* finally draw the scene for this eye */
        drawing.draw(context);

        if(this.device.isStereoEnabled())
          this.tBuffers[eye].unsetRenderSurface();
        else
          break;
      }
      
      return true;

    }
    case ViewportDrawPhase_PostDraw: {

      if(this.tBuffers.size() == 0)
        return false;

      vp.responsibleForSwappingBuffers = this.device.isStereoEnabled();
      if(!vp.responsibleForSwappingBuffers)
        return false;

      glViewport(0, 0, vp.dimensions.x, vp.dimensions.y);
      glClearColor(this.bgColor.r, this.bgColor.g, this.bgColor.b, this.bgColor.a);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

      for(ovrEyeType eye=0; eye<ovrEye_Count; eye++) {
        this.layerEyeFov.RenderPose[eye]   = this.poses[eye];
      }

      this.device.submitFrame(0, this.viewScaleDesc, this.layerEyeFov);

      this.mirror.blitTexture();

      return true;

    }
  }
  return false;
}
